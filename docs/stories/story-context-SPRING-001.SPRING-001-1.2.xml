<story-context id="bmad/bmm/workflows/4-implementation/story-context/template" v="1.0">
  <metadata>
    <epicId>SPRING-001</epicId>
    <storyId>SPRING-001-1.2</storyId>
    <title>Player Entity & Sprite Rendering</title>
    <status>draft</status>
    <generatedAt>2025-10-18</generatedAt>
    <generator>BMAD Story Context Workflow</generator>
    <sourceStoryPath>docs/stories/SPRING-001-1.2-player-sprite.md</sourceStoryPath>
  </metadata>

  <story>
    <asA>a player</asA>
    <iWant>to see my character on screen</iWant>
    <soThat>I know where I am in the game world</soThat>
    <tasks>
      - Create Player struct with position field
      - Initialize player at screen center
      - Implement world_to_screen() coordinate transform
      - Create circle mesh for player sprite
      - Render player in draw() method
      - Verify player appears at correct position
    </tasks>
  </story>

  <acceptanceCriteria>
    <criterion id="AC-1">Player struct created with position (x, y)</criterion>
    <criterion id="AC-2">Player renders as colored circle (placeholder sprite)</criterion>
    <criterion id="AC-3">Player spawns at center of screen (400, 300)</criterion>
    <criterion id="AC-4">World-to-screen coordinate transform implemented</criterion>
    <criterion id="AC-5">Player sprite drawn at correct isometric position</criterion>
  </acceptanceCriteria>

  <artifacts>
    <docs>
      <doc>
        <path>docs/tech-spec-epic-SPRING-001.md</path>
        <title>Technical Specification: Combat Prototype Foundation</title>
        <section>Data Models and Contracts - Player struct</section>
        <snippet>Player struct with pos: Vec2 (world coordinates), velocity, speed (150.0 px/sec), hp (100), radius (16.0 px collision), last_shot_time cooldown tracking.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-SPRING-001.md</path>
        <title>Technical Specification: Combat Prototype Foundation</title>
        <section>Coordinate Systems</section>
        <snippet>World coords (2D Cartesian) vs Screen coords (isometric projection). Transform: screen = world_to_screen(world, camera_offset). Isometric projection rotates 45° and scales Y by 0.5.</snippet>
      </doc>
      <doc>
        <path>docs/tech-spec-epic-SPRING-001.md</path>
        <title>Technical Specification: Combat Prototype Foundation</title>
        <section>Acceptance Criteria AC-1.2</section>
        <snippet>Player struct with Vec2 position. Renders as yellow circle (#FFD700, 16px radius). Spawns at screen center (400, 300). world_to_screen() transforms coords to isometric. Player sprite visible and positioned correctly.</snippet>
      </doc>
      <doc>
        <path>docs/combat-spec.md</path>
        <title>Combat System Specification</title>
        <section>Coordinate System</section>
        <snippet>World space: 2D float (x,y), top-down view, all logic in world space. Screen space: isometric projection. Formula: screen_x = (world_x - world_y) * TILE_WIDTH_HALF, screen_y = (world_x + world_y) * TILE_HEIGHT_HALF. Constants: TILE_WIDTH_HALF=32, TILE_HEIGHT_HALF=16.</snippet>
      </doc>
      <doc>
        <path>docs/combat-spec.md</path>
        <title>Combat System Specification</title>
        <section>Player Movement - Parameters</section>
        <snippet>Base Speed: 150 pixels/second, Collision Radius: 16 pixels (circle collider), Bounds Checking: prevent leaving play area.</snippet>
      </doc>
    </docs>
    <code>
      <artifact>
        <path>src/main.rs</path>
        <kind>main entry point</kind>
        <symbol>GameState, EventHandler impl, main()</symbol>
        <lines>1-42</lines>
        <reason>Existing GameState struct and EventHandler implementation - need to add Player field and render it in draw() method</reason>
      </artifact>
    </code>
    <dependencies>
      <rust>
        <package name="ggez" version="0.9" purpose="Game framework for rendering (Mesh::new_circle), input, windowing, Vec2 type, graphics primitives" />
      </rust>
    </dependencies>
  </artifacts>

  <constraints>
    - Use ggez::graphics::Mesh::new_circle() for placeholder sprite
    - Player color: yellow (#FFD700)
    - Radius: 16 pixels
    - Spawn position: screen center (400, 300) in world coordinates
    - Implement world_to_screen() helper function per tech spec formulas
    - Use TILE_WIDTH_HALF = 32.0, TILE_HEIGHT_HALF = 16.0 constants
    - Rust ownership model requires careful Player field management in GameState
    - No heap allocations in hot path (Player stored directly in GameState, not Box/Rc)
    - 60 FPS target maintained
    - Simple data structures prioritized over premature optimization
  </constraints>

  <interfaces>
    <interface>
      <name>Player struct</name>
      <kind>Data structure</kind>
      <signature>pub struct Player { pub pos: Vec2, pub velocity: Vec2, pub speed: f32, pub hp: i32, pub max_hp: i32, pub radius: f32, pub last_shot_time: f32 }</signature>
      <path>To be created (recommended: src/main.rs initially, or new file src/entities/player.rs)</path>
    </interface>
    <interface>
      <name>world_to_screen</name>
      <kind>Coordinate transform function</kind>
      <signature>pub fn world_to_screen(world_pos: Vec2, camera_offset: Vec2) -> Vec2</signature>
      <path>To be created (recommended: src/main.rs initially, or new file src/systems/coordinate.rs)</path>
    </interface>
    <interface>
      <name>EventHandler::draw</name>
      <kind>Trait method</kind>
      <signature>fn draw(&amp;mut self, ctx: &amp;mut Context) -> GameResult</signature>
      <path>src/main.rs (exists, needs modification to render Player)</path>
    </interface>
    <interface>
      <name>GameState</name>
      <kind>Struct (modification)</kind>
      <signature>struct GameState { player: Player }</signature>
      <path>src/main.rs (exists, needs Player field added)</path>
    </interface>
  </interfaces>

  <tests>
    <standards>Manual playtesting only for Phase 1. No automated tests required. Validate acceptance criteria through gameplay. Visual inspection: player circle appears yellow, correct size, correct position. Measure position via debug output if needed.</standards>
    <locations>N/A - No automated tests in prototype phase. Future: tests/ directory for unit tests of coordinate transforms.</locations>
    <ideas>
      <test-idea ac-ref="AC-1">Verify Player struct compiles with pos field of type Vec2 (ggez::mint::Vector2 or glam::Vec2)</test-idea>
      <test-idea ac-ref="AC-2">Launch game, visually confirm yellow circle (#FFD700) renders on screen with 16px radius</test-idea>
      <test-idea ac-ref="AC-3">Check player spawns at screen center - visual confirmation or add debug println!("Player pos: {:?}", player.pos)</test-idea>
      <test-idea ac-ref="AC-4">Test world_to_screen() with known inputs: (0,0) world → screen coords, (400,300) world → isometric screen position</test-idea>
      <test-idea ac-ref="AC-5">Verify isometric rendering looks correct - player circle drawn with depth perception (isometric formula applied)</test-idea>
    </ideas>
  </tests>
</story-context>
